# Observer Design Pattern

The `Observer Pattern` defines a one-to-many dependency between objects so that when one object changes state, all its dependents
are notified and updated automatically.
The key objects in this pattern are the `subject` and `observer`.
A `subject` may have any number of dependent `observers`.
All `observers` are `notified` whenever the `subject` undergoes a change in its state (also known as an `update` or `event`).
In response, each `observer` will query the `subject` to synchronize its state with the `subject` state.

The following UML diagram illustrates the interfaces and concrete `subject` and `observer` classes involved in the pattern:
```
+--------------------+            +---------------+
| «interface»        |            | «interface»   |
| Subject            |----------->| Observer      |
+--------------------+            +---------------+
| registerObserver() |            | update()      |
| removeObserver()   |            +---------------+
| notifyObserver()   |                   ^
+--------------------+                   |
          ^                              |
          |                              |
          |                              |
+--------------------+          +------------------+
| ConcreteSubject    |<---------| ConcreteObserver |
+--------------------+          +------------------+
| update()           |          | update()         |
| registerObserver() |          | more methods...  |
| removeObserver()   |          +------------------+
| notifyObserver()   |
| more methods...    |
+--------------------+
```
Based on the above UML diagram, there are four participants in the `Observer pattern`:
- `Subject`: which is used to register `observers`. Objects use this interface to register as `observers` and also to remove themselves from being `observers`.
- `Observer`: defines an updating interface for objects that should be notified of changes in a `subject`. All `observers` need to
implement the `Observer` interface. This interface has a method `update()`, which gets called when the `Subject’s` state changes.
- `ConcreteSubject`: stores the state of interest to `ConcreteObserver` objects. It sends a notification to its `observers` when its state changes. A concrete `subject` always implements the `Subject` interface. The `notifyObservers()` method is used to update
all the current `observers` whenever the state changes.
- `ConcreateObserver`: maintains a reference to a `ConcreteSubject` object and implements the `Observer` interface. Each `observer` registers with a concrete `subject` to receive updates.

#### Task: to create `The Economist` magazine using the `Observer Pattern`:

A common way to understand the `Observer Pattern` is considering the way the `Publisher-Subscriber` relationship works.
Let's look at an example of the `Observer Pattern` using the following requirements:
- [x] Use the `Observer pattern`;
- [x] Online, mobile and physical subscriptions should be modelled;
- [x] `main` method should send out magazines every 3 seconds (using Thread.sleep);
- [x] Only one publisher (the Economist), but 15 subscribers who are going to give the magazine a rating of 1-6 (at random) whenever they receive a magazine(in a system.out.println message);
- [x] The output should be in the format: `Magazine, subscriptionType, rating` as a String.

Here is the implementation:
```java
import java.sql.Timestamp;
import java.util.Date;
import java.util.HashSet;
import java.util.Set;

// The main method
public class EconomistObserverDemo {
    public static void main(String[] args) {
        // The subject.
        Economist economist = new Economist();
        // The 15 observers.
        Subscriber onlineSubscriber01 = new OnlineSubscription(economist);
        Subscriber mobileSubscriber01 = new MobileSubscription(economist);
        Subscriber physicalSubscriber01 = new PhysicalSubscription(economist);
        Subscriber onlineSubscriber02 = new OnlineSubscription(economist);
        Subscriber mobileSubscriber02 = new MobileSubscription(economist);
        Subscriber physicalSubscriber02 = new PhysicalSubscription(economist);
        Subscriber onlineSubscriber03 = new OnlineSubscription(economist);
        Subscriber mobileSubscriber03 = new MobileSubscription(economist);
        Subscriber physicalSubscriber03 = new PhysicalSubscription(economist);
        Subscriber onlineSubscriber04 = new OnlineSubscription(economist);
        Subscriber mobileSubscriber04 = new MobileSubscription(economist);
        Subscriber physicalSubscriber04 = new PhysicalSubscription(economist);
        Subscriber onlineSubscriber05 = new OnlineSubscription(economist);
        Subscriber mobileSubscriber05 = new MobileSubscription(economist);
        Subscriber physicalSubscriber05 = new PhysicalSubscription(economist);
        // 15 events generated by the subject, each 3 sec apart.
        for (int i = 0; i < 15; i++) {
            economist.onEvent(new Event());
            try {
                int waitTime = 3000;
                Thread.sleep(waitTime);
            } catch (InterruptedException e) {
                System.out.println(e);
            }
        }
    }
}

// The Event class: this is what the subject sends out to the observers.
class Event {
    Event() {
        Date date = new Date();
        System.out.println("\nA new set of reviews for the subscribers of magazines at: " + new Timestamp(date.getTime()));
    }
}

// The Economist class: this is the concrete subject. This one uses a Set of Subscribers, but this could also be a List.
// The register method allows the observers to register.
// The onEvent method loops through all the observers and notifies them of the event if they are registered.
class Economist {
    private Set<Subscriber> subscribers = new HashSet<>();

    void register(Subscriber subscriber) {
        subscribers.add(subscriber);
    }

    void onEvent(Event ev) {
        for (Subscriber ob : subscribers) {
            ob.notify(ev);
        }
    }
}

// The Subscriber interface: the is the observer's interface.
interface Subscriber {
    void notify(Event ev);
}

// This class creates a random number between 1 - 5 for the rating.
class SubscriberRating {
    int getRand() {
        int min = 1;
        int max = 6;
        int range = max - min + 1;
        return (int) (Math.random() * range) + min;
    }
}

// This is one of the observers, it registers to the subject, and the notify method listens out for the events.
// When events occur, it generates a rating, and prints out the desired String.
class OnlineSubscription implements Subscriber {
    OnlineSubscription(Economist economist) {
        economist.register(this);
    }

    @Override
    public void notify(final Event ev) {
        SubscriberRating subscriberRating = new SubscriberRating();
        System.out.println(OnlineSubscription.class.getName() + " of the Economist gives a rating: " + subscriberRating.getRand());
    }
}

// The second observer.
class PhysicalSubscription implements Subscriber {
    PhysicalSubscription(Economist economist) {
        economist.register(this);
    }

    @Override
    public void notify(final Event ev) {
        SubscriberRating subscriberRating = new SubscriberRating();
        System.out.println(PhysicalSubscription.class.getName() + " of the Economist gives a rating: " + subscriberRating.getRand());
    }
}

// The third observer.
class MobileSubscription implements Subscriber {
    MobileSubscription(Economist economist) {
        economist.register(this);
    }

    @Override
    public void notify(final Event ev) {
        SubscriberRating subscriberRating = new SubscriberRating();
        System.out.println(MobileSubscription.class.getName() + " of the Economist gives a rating: " + subscriberRating.getRand());
    }
}
```
